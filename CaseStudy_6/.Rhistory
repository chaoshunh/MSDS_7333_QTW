else {
# Get preformatted text from <pre> elements
pres = getNodeSet(doc, "//pre")
txt = xmlValue(pres[[1]])
els = strsplit(txt, "\r\n")[[1]]
}
if (is.null(file)) return(els)
# Write the lines as a text file.
writeLines(els, con = file)
}
years = 1999:2012
menTables = mapply(extractResTable, url = urls, year = years)
names(menTables) = years
sapply(menTables, length)
menTables[1]
menTables[1]
ffx = getNodeSet(doctmp, "//body")
extractResTable =
#
# Retrieve data from web site,
# find the preformatted text,
# and write lines or return as a character vector.
#
function(url = "http://www.cherryblossom.org/results/2009/09cucb-F.htm",
year = 1999, sex = "male", file = NULL)
{
doc = htmlParse(url)
if (year == 1999) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
gg = getNodeSet(doc, "//body")
txt = xmlValue(gg[[2]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2000) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
ff = getNodeSet(doc, "//font")
txt = xmlValue(ff[[4]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2009 & sex == "male") {
# Get preformatted text from <div class="Section1"> element
# Each line of results is in a <pre> element
div1 = getNodeSet(doc, "//div[@class='Section1']")
pres = getNodeSet(div1[[1]], "//pre")
els = sapply(pres, xmlValue)
}
else {
# Get preformatted text from <pre> elements
pres = getNodeSet(doc, "//pre")
txt = xmlValue(pres[[1]])
els = strsplit(txt, "\r\n")[[1]]
}
if (is.null(file)) return(els)
# Write the lines as a text file.
writeLines(els, con = file)
}
years = 1999:2012
menTables = mapply(extractResTable, url = urls, year = years)
0
extractResTable =
#
# Retrieve data from web site,
# find the preformatted text,
# and write lines or return as a character vector.
#
function(url = "http://www.cherryblossom.org/results/2009/09cucb-F.htm",
year = 1999, sex = "male", file = NULL)
{
doc = htmlParse(url)
if (year == 1999) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
gg = getNodeSet(doc, "//body")
txt = xmlValue(gg[[2]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2000) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
ff = getNodeSet(doc, "//font")
txt = xmlValue(ff[[4]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2009 & sex == "male") {
# Get preformatted text from <div class="Section1"> element
# Each line of results is in a <pre> element
div1 = getNodeSet(doc, "//div[@class='Section1']")
pres = getNodeSet(div1[[1]], "//pre")
els = sapply(pres, xmlValue)
}
else {
# Get preformatted text from <pre> elements
pres = getNodeSet(doc, "//pre")
txt = xmlValue(pres[[1]])
els = strsplit(txt, "\r\n")[[1]]
}
if (is.null(file)) return(els)
# Write the lines as a text file.
writeLines(els, con = file)
}
years = 1999:2012
menTables = mapply(extractResTable, url = urls, year = years)
names(menTables) = years
sapply(menTables, length)
extractResTable =
#
# Retrieve data from web site,
# find the preformatted text,
# and write lines or return as a character vector.
#
function(url = "http://www.cherryblossom.org/results/2009/09cucb-F.htm",
year = 1999, sex = "male", file = NULL)
{
doc = htmlParse(url)
if (year == 1999) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
gg = getNodeSet(doc, "//body")
txt = xmlValue(gg[[1]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2000) {
# Get preformatted text from 4th font element
# The top file is ill formed so the <pre> search doesn't work.
ff = getNodeSet(doc, "//font")
txt = xmlValue(ff[[4]])
els = strsplit(txt, "\r\n")[[1]]
}
else if (year == 2009 & sex == "male") {
# Get preformatted text from <div class="Section1"> element
# Each line of results is in a <pre> element
div1 = getNodeSet(doc, "//div[@class='Section1']")
pres = getNodeSet(div1[[1]], "//pre")
els = sapply(pres, xmlValue)
}
else {
# Get preformatted text from <pre> elements
pres = getNodeSet(doc, "//pre")
txt = xmlValue(pres[[1]])
els = strsplit(txt, "\r\n")[[1]]
}
if (is.null(file)) return(els)
# Write the lines as a text file.
writeLines(els, con = file)
}
years = 1999:2012
menTables = mapply(extractResTable, url = urls, year = years)
names(menTables) = years
sapply(menTables, length)
spamPath = system.file(package = "RSpamData")
install.packages("RSpamData")
spamPath = "./SpamAssassinMessages/"
list.dirs(spamPath, full.names = FALSE)
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
current_path <- getActiveDocumentContext()$path
library(os)
library(rstudioapi)
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
spamPath = "./SpamAssassinMessages/"
list.dirs(spamPath, full.names = FALSE)
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
head(list.files(path = paste(spamPath, "messages", "spam_2",
sep = .Platform$file.sep)))
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
spamPath = "./SpamAssassinMessages/"
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
head(list.files(path = paste(spamPath, "messages", "spam_2",
sep = .Platform$file.sep)))
dirNames = list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
length(list.files(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)))
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
fullDirNames = paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)
fileNames = list.files(fullDirNames[1], full.names = TRUE)
fileNames[1]
msg = readLines(fileNames[1])
head(msg)
indx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)
fn = list.files(fullDirNames[1], full.names = TRUE)[indx]
sampleEmail = sapply(fn, readLines)
msg = sampleEmail[[1]]
which(msg == "")[1]
library(rstudioapi)
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
spamPath = "./SpamAssassinMessages/"
list.dirs(spamPath, full.names = FALSE)
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
head(list.files(path = paste(spamPath, "messages", "spam_2",
sep = .Platform$file.sep)))
dirNames = list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
length(list.files(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)))
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
fullDirNames = paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)
fileNames = list.files(fullDirNames[1], full.names = TRUE)
fileNames[1]
list.dirs(spamPath, full.names = FALSE)
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep)
)
head(list.files(path = paste(spamPath, "messages", "spam_2",
sep = .Platform$file.sep)))
dirNames = list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
length(list.files(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)))
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
fullDirNames = paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)
fullDirNames
fileNames = list.files(fullDirNames[1], full.names = TRUE)
fileNames[1]
msg = readLines(fileNames[1])
head(msg)
indx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)
fileNames
indx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)
fn = list.files(fullDirNames[1], full.names = TRUE)[indx]
sampleEmail = sapply(fn, readLines)
sampleEmail = sapply(fn, readLines)
sampleEmail
fn
fn
sampleEmail
typeof(sampleEmail)
sapply(sampleEmail,class)
lapply(sampleEmail,class)
class(msg)
msg
class(msg)
type.of(msg)
is.matrix(msg)
is.vector(msg)
lapply(sampleEmail,class)
lapply(sampleEmail,type.of)
fn
which(msg == "")[1]
match("", msg)
??match()
?match()
msg = sampleEmail[[2]]
which(msg == "")[1] # Identifying first blank line in message (This is to find the first blank line
which(msg == "") # Identifying first blank line in message (This is to find the first blank line
match("", msg)
splitPoint = match("", msg)
splitPoint
fn = list.files(fullDirNames[1], full.names = TRUE)[indx]
sampleEmail = sapply(fn, readLines) # Creates a list of 15 character vectors
# Subsetting out first message in easy_ham directory for analysis
msg = sampleEmail[[1]]
which(msg == "")[1] # Identifying first blank line in message (This is to find the first blank line,
# by using the [1], in the message, which indicates the separation between header
# and body of email) Without index [1], would return a index of all blank lines
#[1] 63
match("", msg) # Another way to identifying the first blank line in message/vector)
# going to create a splitpoint, using the first blank line as the argument
splitPoint = match("", msg)
msg[ (splitPoint - 2):(splitPoint + 6) ]
header = msg[1:(splitPoint-1)]
header = msg[1:(splitPoint-1)] # Creating Header of message: everything above splitPoint
body = msg[ -(1:splitPoint) ] # Creating Body of message: everything below SplitPoint
body
#----------- splitMessage function () - Rev A ----------
# Split message into header and body, using 1st blank line
# as the split Point
splitMessage = function(msg) {
splitPoint = match("", msg)
header = msg[1:(splitPoint-1)]
body = msg[ -(1:splitPoint) ]
return(list(header = header, body = body))
}
sampleSplit = lapply(sampleEmail, splitMessage)
sapply(sampleSplit)
sapply(sampleSplit, class)
sampleSplit$header
sampleSplit[[1]]$header
head(sampleSplit[[1]]$header,4)
head(sampleSplit[[1]]$header)
head(sampleSplit[[2]]$body)
header = sampleSplit[[1]]$header
grep("Content-Type", header) #identifying content type of message #1
grep("multi", tolower(header[46]))
header[46]
header[46]
?grep()
headerList = lapply(sampleSplit, function(msg) msg$header)
CTloc = sapply(headerList, grep, pattern = "Content-Type")
CTloc
count(CTloc!=0)
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
CTloc
})
CTloc
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
# CTloc
})
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
CTloc
})
hasAttach = sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(FALSE)
grepl("multi", tolower(header[CTloc]))
})
hasAttach
?grepl()
library(rstudioapi)
current_path <- getActiveDocumentContext()$path
setwd(dirname(current_path ))
spamPath = "./SpamAssassinMessages/"
list.dirs(spamPath, full.names = FALSE)
# [1] ""                    "Messages"            "Messages/easy_ham"   "Messages/easy_ham_2" "Messages/hard_ham"
# [6] "Messages/spam"       "Messages/spam_2"
# Listing folders in Message directory
list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
# [1] "easy_ham"   "easy_ham_2" "hard_ham"   "spam"       "spam_2"
# examime the first few file names in spam_2 foloder
# The files are named by message number and their MD5 checksum hash
head(list.files(path = paste(spamPath, "messages", "spam_2",
sep = .Platform$file.sep)))
dirNames = list.files(path = paste(spamPath, "messages",
sep = .Platform$file.sep))
# Check to see how many files located in the Messages directories
length(list.files(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)))
# [1] 9354
# Getting a count of files in each of Messages subdirectories
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
# ./SpamAssassinMessages//messages/easy_ham ./SpamAssassinMessages//messages/easy_ham_2
# 5052                                        1401
# ./SpamAssassinMessages//messages/hard_ham       ./SpamAssassinMessages//messages/spam
# Check to see how many files located in the Messages directories
length(list.files(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)))
# [1] 9354
# Getting a count of files in each of Messages subdirectories
sapply(paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep),
function(dir) length(list.files(dir)) )
# ./SpamAssassinMessages//messages/easy_ham ./SpamAssassinMessages//messages/easy_ham_2
# 5052                                        1401
# ./SpamAssassinMessages//messages/hard_ham       ./SpamAssassinMessages//messages/spam
# Creating a list of directory names/paths for use in retrieving data
fullDirNames = paste(spamPath, "messages", dirNames,
sep = .Platform$file.sep)
# ------ Test Code -----
# List first message/file from messages/easy_ham
fileNames = list.files(fullDirNames[1], full.names = TRUE)
fileNames[1] #[1] "./SpamAssassinMessages//messages/easy_ham/00001.7c53336b37003a9286aba55d2945844c"
# Read and display the first few lines of the first message in easy_ham
msg = readLines(fileNames[1])
head(msg)
# [1] "From exmh-workers-admin@redhat.com  Thu Aug 22 12:36:23 2002"
# [2] "Return-Path: <exmh-workers-admin@spamassassin.taint.org>"
# [3] "Delivered-To: zzzz@localhost.netnoteinc.com"
# [4] "Received: from localhost (localhost [127.0.0.1])"
# [5] "\tby phobos.labs.netnoteinc.com (Postfix) with ESMTP id D03E543C36"
# [6] "\tfor <zzzz@localhost>; Thu, 22 Aug 2002 07:36:16 -0400 (EDT)"
# Selecting 15 files from easy_ham directory to read
indx = c(1:5, 15, 27, 68, 69, 329, 404, 427, 516, 852, 971)
fn = list.files(fullDirNames[1], full.names = TRUE)[indx]
sampleEmail = sapply(fn, readLines) # Creates a list of 15 character vectors
# Subsetting out first message in easy_ham directory for analysis
msg = sampleEmail[[1]]
which(msg == "")[1] # Identifying first blank line in message (This is to find the first blank line,
# by using the [1], in the message, which indicates the separation between header
match("", msg) # Another way to identifying the first blank line in message/vector)
# going to create a splitpoint, using the first blank line as the argument
splitPoint = match("", msg)
#Splitting message into header/body, using splitPoint index as the argument
# Creating msg using the last 2 lines of header and first 6 lines of body
msg[ (splitPoint - 2):(splitPoint + 6) ]
# [1] "List-Archive: <https://listman.spamassassin.taint.org/mailman/private/exmh-workers/>"
# [2] "Date: Thu, 22 Aug 2002 18:26:25 +0700"
# [3] ""
# [4] "    Date:        Wed, 21 Aug 2002 10:54:46 -0500"
# [5] "    From:        Chris Garrigues <cwg-dated-1030377287.06fa6d@DeepEddy.Com>"
# [6] "    Message-ID:  <1029945287.4797.TMDA@deepeddy.vircio.com>"
# [7] ""
# [8] ""
# [9] "  | I can't reproduce this error."
header = msg[1:(splitPoint-1)] # Creating Header of message: everything above splitPoint
body = msg[ -(1:splitPoint) ] # Creating Body of message: everything below SplitPoint
#----------- splitMessage function () - Rev A ----------
# Split message into two character vectors (header and body) list, using 1st blank line
# as the split Point
splitMessage = function(msg) {
splitPoint = match("", msg)
header = msg[1:(splitPoint-1)]
body = msg[ -(1:splitPoint) ]
return(list(header = header, body = body))
}
#---
# Add a check to deal with missing 'Content-Type' keys
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
CTloc
})
# Function to determines the content type of all 15 test emails
headerList = lapply(sampleSplit, function(msg) msg$header)
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
CTloc
})
# Function to determines the content type of all 15 test emails
headerList = lapply(sampleSplit, function(msg) msg$header)
sampleSplit = lapply(sampleEmail, splitMessage) #Testing code on list of 15 previously select messages
headerList = lapply(sampleSplit, function(msg) msg$header)
CTloc = sapply(headerList, grep, pattern = "Content-Type")
CTloc # Does not work properly becuase the 7th element does not have a 'content-Type' Key
# Add a check to deal with missing 'Content-Type' keys
sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(NA)
CTloc
})
# Creation of Boolean variable to determine if message contains an attachment
hasAttach = sapply(headerList, function(header) {
CTloc = grep("Content-Type", header)
if (length(CTloc) == 0) return(FALSE)
grepl("multi", tolower(header[CTloc]))
})
hasAttach
hasAttach[[1]]
hasAttach[[6]]
c = hasAttach
c
print(unname(hasAttach))
hasAttach
print(unname(CTloc))
header = sampleSplit[[6]]$header
header = sampleSplit[[6]]$header # We know message 6 includes an attachment
boundaryIdx = grep("boundary=", header)
header[boundaryIdx]
boundaryIdx
header[boundaryIdx]
sub(".*boundary=\"(.*)\";.*", "\\1", header[boundaryIdx]) # We want to extract the
header[boundaryIdx]
?sub()
sub(".*boundary=\"(.*)\";.*", "\\2", header[boundaryIdx]) # We want to extract the boundry value, which follows the boundry
# [1] "==_Exmh_-1317289252P"                              # statement and is grouped, using the ( ) which must be followed
#?sub()                                                   # by "; giving access to characters located within the ( ) using
sub(".*boundary=\"(.*)\";.*", "\\1", header[boundaryIdx]) # We want to extract the boundry value, which follows the boundry
# [1] "==_Exmh_-1317289252P"                              # statement and is grouped, using the ( ) which must be followed
#?sub()                                                   # by "; giving access to characters located within the ( ) using
# //1 notatoin.  Complete description on pg 119
header2 = headerList[[9]]
boundaryIdx2 = grep("boundary=", header2)
boundaryIdx2
header2[boundaryIdx2]
sub('.*boundary="(.*)";.*', "\\1", header2[boundaryIdx2])
boundary2 = gsub('"', "", header2[boundaryIdx2])
boundary2
boundary2
sub(".*boundary= *(.*);?.*", "\\1", boundary2) # modified sub statement to not serach for quotation marks
boundary = gsub('"', "", header[boundaryIdx])
sub(".*boundary= *(.*);?.*", "\\1", boundary)
sub(".*boundary= *([^;]*);?.*", "\\1", boundary)
getBoundary = function(header) {
boundaryIdx = grep("boundary=", header)
boundary = gsub('"', "", header[boundaryIdx])
gsub(".*boundary= *([^;]*);?.*", "\\1", boundary)
}
sapply(headerList, getBoundary)
c <- sapply(headerList, getBoundary)
print(unname(c))
testingBoundry <- sapply(headerList, getBoundary)
print(unname(testingBoundry))
